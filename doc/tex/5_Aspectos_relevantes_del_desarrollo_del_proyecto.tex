\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}

\section{Resumen del trabajo}

Este trabajo aborda la creación de una herramienta automatizada para la clasificación de \textit{malware} en Android mediante análisis estático. La estrategia consiste en examinar las aplicaciones de forma segura, sin ejecutarlas, para que un modelo de inteligencia artificial evalúe sus características y determine si son o no maliciosas. El proyecto se desarrolló en dos fases diferentes: una inicial de prototipado y una segunda de desarrollo y refinamiento de la solución final.

La primera fase exploró el estado del arte y validó, mediante un prototipo de red neuronal, que es posible distinguir aplicaciones benignas de malignas usando únicamente sus características estáticas. Sin embargo, este primer modelo se entrenó con un \textit{dataset} preexistente cuyo proceso de creación era una ''caja negra'', lo que puso de manifiesto un grave problema, la incapacidad de aplicar el modelo a nuevas muestras por no saber cómo preparar los datos de entrada.

Para resolver este problema, la segunda fase se centró en la creación de un \textit{dataset} propio, desarrollando un extractor de características replicable con Androguard. Sobre esta nueva base, se construyó y optimizó un nuevo modelo que, al ser evaluado, reveló un hallazgo interesante. Si bien el rendimiento de la red neuronal es excelente, su mayor valor reside en su \textit{embedder}, el componente que transforma los datos en una representación que la red puede entender. Este demostró ser tan eficaz que permitió entrenar otros clasificadores más simples y ligeros con resultados igualmente buenos o incluso mejores que los del modelo principal, convirtiendo a la red en una herramienta muy útil para habilitar la creación de otros modelos que cumplan con este propósito de detectar \textit{malware}.

\section{Pruebas iniciales y estado del arte}
% Pruebas iniciales con el dataset de drebin
% - Adaptación del dataset a un dataframe / csv
% - Creación del modelo simple, mlp y embedder
% - Proceso de entrenamiento y de entrenamiento de los otros modelos de ml
% - Proceso de carga y guardado de los modelos
% - Proceso de obtención de gráficas y datos

\subsection{Base del proyecto}
% Papaer en el que nos basamos (a lo mejor debería ir en la parte de los papers)

\subsection{El dataset de Drebin}

\subsection{Creación de un modelo prototipo}

\subsection{Entrenamiento del modelo}

\subsection{Análisis de datos preliminar}



\section{Extracción de caracteísticas y \textit{dataset} propio}
% Creación del dataset propio
% - Filtrado y descarga de las apks
% - Pruebas de extración de características con androguard
% - Creación de un proceso automatizado y creación del dataset

\subsection{Pruebas con Androguard}

\subsection{Automatización del proceso de creación del \textit{dataset}}



\section{Desarrollo y optimización del modelo final}

\subsection{Adaptación del modelo al nuevo set de datos}
% Adaptación modificación del modelo a los datos actuales
% - Añadir el gru para el procesador del fuzzy hash
% - Añadir los opcodes y el procesado de estos (procesado de vectores)
% - Añadir los escalares (tamaño del archivo)
% - Cambiar el proceso de training

\subsection{Problemas imprevistos}
% Problemas que el modelo nuevo trajo a la mesa (complejidad mucho mayor y un mal diseño del sistema inicial)
% - Optimizaciones empleadas
%   - Preprocesar datos fuera del modelo (ya no era factible no hacerlo para este caso) y pasar todos los tipos de forma cuidadosa a tipos más óptimos como los que numpy provee, sobretodo para aprovechar la vectorización de operaciones
%   - Añadir el scheaduler para el learning rate
%   - Añadir auto grad (evitar gradient clipping)
%   - Añadir auto cast (operar con datos a menor precisión cuando sea posible)
% 	- Limpiar memoria innecesaria

\subsection{Búsqueda de hiperparámetros óptimos}
% Búsqueda de hiperparámetros optimos mediante optuna
% - Explicar proceso y resultados

\subsection{Análisis de los resultados}
% Comparativas de rendimiento

\subsection{Cuantización del modelo}
% (maybe) Quantización del modelo
% - Explicar proceso y si merece la pena comparado con el original



\section{Desarrollo de la aplicación web}
% Desarrollo de la aplicación web
% - Explicar proceso y funcionalidades básicas
% - (maybe) incluir boton de historial en local storage y mini base de datos sqlite, comparativo con múltiples modelos y estadísticas
% - Dockerizar y desplegar

\subsection{Creación de la web}

\subsection{\textit{Dockerización} y despliegue}
 